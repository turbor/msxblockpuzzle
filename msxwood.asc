include "bios.asc"

WRVDP	MACRO	@WAARDE,@POORT
	; {{{
	LD	A,@WAARDE
	OUT	(#99),A
	LD	A,128+@POORT
	OUT	(#99),A
	ENDM
	; }}}

chkvdp2	macro
	; {{{
	LOCAL chkvdp2@sym
chkvdp2@sym
	in	a,(#99)
	rrca
	jp	c,chkvdp2@sym
	endm
	; }}}

DEBUG equ 0

;This code is used in conjunction with the openMSX debugdevice to help debug/time my code
debugdeviceascii macro @TEXTVAL
	; {{{
	if DEBUG
	LOCAL _debugdevicetmp
	LOCAL _debugdevicetmp2
	jr _debugdevicetmp2
_debugdevicetmp 
	db @TEXTVAL
_debugdevicetmp2
	ld a,0x58
	out (0x2e),a
	ld a,'-'
	out (0x2f),a
	ld a,0x63
	out (0x2e),a
	ld hl,_debugdevicetmp
	ld c,0x2f
	ld b,_debugdevicetmp2-_debugdevicetmp
	otir
	ld a,0x03
	out (0x2e),a
	ld a,'-'
	out (0x2f),a
	endif
	endm
	; }}}

START	EQU	#4000

BUFROWS	EQU 8
BUFCOLS EQU 8

; created by pasmo  and the --bin switch, the org command should be the first one seen by pasmo
	org	START
	db 'AB' ; expansion ROM header
	DW initcode ; start of the init code, 0 if no initcode
	DW 0 ; pointer to CALL statement handler, 0 if no such handler
	DW 0 ; pointer to expansion device handler, 0 if no such handler
	DW 0 ; pointer to the start of a tokenized basicprogram, 0 if no basicprogram
	DW 0,0,0 ; room reserved for future extensions
initcode:

initgame:
	call init
	call createbigcharset
startgame:
	call initscore
	call showscore
	call initplayfield
	call gridbitmap_to_grid10x10
	call selectnewplayablepieces
	call playablepieces_to_nametabel
	; shortcut since last elements is now already in mask
	ld a,2
	ld (pieceplayednowselected),a
	ld a,(pieceplayable3)
	ld (pieceplayednow),a
	call select_next_piece ; when we start the first piece is selected

	xor a
	ld (gameover),a
	call check_possible_gameover ; debug field might be to crowded...

maincount:
	call item_place_color
	call move_item_by_user
	ld a,(pieceplaceingrid)
	or a
	jr z,maincount3
	call drop_piece_in_grid
	jr z,maincount3 ; didn't drop anything
	call check_new_pieces_needed ; Z if new items
	call check_possible_gameover ; new or old items game over possible...
maincount3:
	ld a,(pieceplacenextpiece)
	or a
	call nz,select_next_piece
	ei
	halt
	call grid10x10_to_nametabel		; draw grid
	call item_to_nametabel		; draw item over grid
	call execroutine	; perform all extra routine before writting to vram the gridnametable, this allows extra animation in these routines to be displayed on top of the playingfield!
	call gridnametabel_to_vram
	call grid10x10_do_animation
	;no 10x10 disapear animation anymore and still no new itemselected...
	; auto select next piece
	ld a,(grid10x10_do_animation_inprogress)
	or a
	jr nz,maincount4
	ld a,(emptyitemmask)
	or a
	call z,select_next_piece
maincount4:
	halt
	call increasedisplayscore
	ld a,(gameover)
	or a
	jp z,maincount
	;show gameover
	call showgameover
	jp startgame


init:
	; first clear all variables to zero
	;especially needed for the routeinstack!!
	ld de,#c001
	ld hl,#c000
	xor a
	ld (hl),a
	ld bc,endvarspace-#c000
	ldir
	ld a,2
	call CHGMOD	; screen 2
	xor a
	ld (CLIKSW),a	; disable keyboard click

	call DISSCR	; disable screen
	ld hl,vrampat1
	ld de,0
	ld bc,vrampat1end-vrampat1 ;256*8
	call LDIRVM	; copy patern table
	
commonchars equ 51
	ld hl,vrampat1
	ld de,256*8
	ld bc,commonchars*8
	call LDIRVM	; copy patern table
	ld hl,vrampat2
	ld de,256*8+commonchars*8
	ld bc,vrampat2end-vrampat2
	call LDIRVM	; copy patern table

	ld hl,vrampat1
	ld de,256*16
	ld bc,commonchars*8
	call LDIRVM	; copy patern table
	ld hl,vrampat3
	ld de,256*16+commonchars*8
	ld bc,vrampat3end-vrampat3
	call LDIRVM	; copy patern table

	ld hl,vramcol1
	ld de,0x2000
	ld bc,vramcol1end-vramcol1 ;256*8
	call LDIRVM	; copy color table

	ld hl,vramcol1
	ld de,0x2000+256*8
	ld bc,commonchars*8
	call LDIRVM	; copy color table
	ld hl,vramcol2
	ld de,0x2000+256*8+commonchars*8
	ld bc,vramcol2end-vramcol2 
	call LDIRVM	; copy color table

	ld hl,vramcol1
	ld de,0x2000+256*16
	ld bc,commonchars*8
	call LDIRVM	; copy color table
	ld hl,vramcol3
	ld de,0x2000+256*16+commonchars*8
	ld bc,vramcol3end-vramcol3 
	call LDIRVM	; copy color table

	ld hl,vramname1
	ld de,0x1800
	ld bc,vramname1end-vramname1
	call LDIRVM	; copy color table

	call ENASCR	; enable screen
	
	;copy nametable to workarrea
	ld hl,vramname1
	ld de,nametabel
	ld bc,vramname1end-vramname1
	ldir
	
	ret

initscore:
	ld hl,0
	ld (pieceoffset),hl
	xor a
	ld (pieceplaceingrid),a
	ld (pieceplacenextpiece),a

	ld hl,itemmask
	ld de,itemmask+1
	xor a
	ld (hl),a
	ld bc,20
	ldir

	xor a
	ld hl,realscore
	ld (hl),a
	ld de,realscore+1
	ld bc,23
	ldir
	ld a,3
	ld (increasedisplayspeedcnt),a
	ld (increasedisplayspeed),a
	ld a,255
	ld (hiscore),a
	ld (realscore),a
	ld (blockscore),a
	ld (displayscore),a
	ld (hiscore+7),a
	ld (realscore+7),a
	ld (blockscore+7),a
	ld (displayscore+7),a
	ld hl,#0
	ld (realscore+1),hl
	ld (realscore+3),hl
	ld hl,#0000
	ld (realscore+5),hl
	ret


increasedisplayscore:
	; not every interrupt we want to check this!
	ld a,(increasedisplayspeedcnt)
	dec a
	ld (increasedisplayspeedcnt),a
	ret nz
	ld a,(increasedisplayspeed)
	ld (increasedisplayspeedcnt),a

	; time to check!
	; are we displaying correct  score?
	ld hl,displayscore+1
	ld de,realscore+1
	call bcdcmpdehl
	ret z

	; increase displayed score by one
	ld hl,displayscore+5+1
	ld de,score0001+5+1
	call bcdadddehl
showscore:
	ld hl,displayscore+1
	ld de,#1800+32*21+14-6 ; vram destination
	ld ix,nametabel+32*21+14-6
	ld bc,#3433 ; offset for numbers in b, empty char in c
	call shownumbers

	ld hl,displayscore+1
	ld de,#1800+32*22+14-6 ; vram destination
	ld ix,nametabel+32*22+14-6
	ld bc,#3f3e ; offset for numbers in b, empty char in c
	call shownumbers
	ret

	
shownumbers:
	push ix
	push bc
	push hl
	ex de,hl
	call SETWRT
	pop hl
	pop bc
	pop de
	ld a,b
	push af
	ld b,5 ; max number of invisible prefixes
shownumber1:
	ld a,(hl)
	or a
	jp nz,shownumbers3
	ld a,c
	out (#98),a
	ld (de),a
	inc de
	inc hl
	djnz shownumber1
shownumbers3:	
	inc b
	pop af
	ld c,a
shownumbers4:	
	ld a,(hl)
	add a,c
	out (#98),a
	inc hl
	ld (de),a
	inc de
	djnz shownumbers4
	ret
	
	
DESTPAGE:	db 0

vrampat1:	
	INCLUDE "vram-pat1.txt"
vrampat1end:
vrampat2:	
	INCLUDE "vram-pat2.txt"
vrampat2end:
vrampat3:	
	INCLUDE "vram-pat3.txt"
vrampat3end:


vramcol1:
	INCLUDE "vram-col1.txt"
vramcol1end:
vramcol2:
	INCLUDE "vram-col2.txt"
vramcol2end:
vramcol3:
	INCLUDE "vram-col3.txt"
vramcol3end:

vramname1:
	INCLUDE "vram-name.txt"
vramname1end:

vrampatgameover:
	INCLUDE "vram-patgameover.txt"
vrampatgameoverend:
vramcolgameover:
	INCLUDE "vram-colgameover.txt"
vramcolgameoverend:
vramnamegameover:
	INCLUDE "vram-namegameover.txt"
vramnamegameoverend:
	INCLUDE "pieces.asc"
	INCLUDE "piecelib.asc"
	INCLUDE "joystick.asc"
	INCLUDE "gameover.asc"

score0001:	db 255,0,0,0,0,0,1,255

	INCLUDE "bcdlib.asc"
	INCLUDE "gridbitmapmanipulators.asc"
	INCLUDE "boxcopy.asc"
	INCLUDE "routines.asc"
	INCLUDE "charanimation.asc"
	INCLUDE "bigscroller.asc"

einde	equ $
	ds #8000-einde

	INCLUDE "variablespace.asc"


;	vim:foldmethod=marker:ft=z8a:ts=16
