include "bios.asc"

WRVDP	MACRO	@WAARDE,@POORT
	; {{{
	LD	A,@WAARDE
	OUT	(#99),A
	LD	A,128+@POORT
	OUT	(#99),A
	ENDM
	; }}}

chkvdp2	macro
	; {{{
	LOCAL chkvdp2@sym
chkvdp2@sym
	in	a,(#99)
	rrca
	jp	c,chkvdp2@sym
	endm
	; }}}

DEBUG equ 0

;This code is used in conjunction with the openMSX debugdevice to help debug/time my code
debugdeviceascii macro @TEXTVAL
	; {{{
	if DEBUG
	LOCAL _debugdevicetmp
	LOCAL _debugdevicetmp2
	jr _debugdevicetmp2
_debugdevicetmp 
	db @TEXTVAL
_debugdevicetmp2
	ld a,0x58
	out (0x2e),a
	ld a,'-'
	out (0x2f),a
	ld a,0x63
	out (0x2e),a
	ld hl,_debugdevicetmp
	ld c,0x2f
	ld b,_debugdevicetmp2-_debugdevicetmp
	otir
	ld a,0x03
	out (0x2e),a
	ld a,'-'
	out (0x2f),a
	endif
	endm
	; }}}

START	EQU	#4000

BUFROWS	EQU 8
BUFCOLS EQU 8

; created by pasmo  and the --bin switch, the org command should be the first one seen by pasmo
	org	START
	db 'AB' ; expansion ROM header
	DW initcode ; start of the init code, 0 if no initcode
	DW 0 ; pointer to CALL statement handler, 0 if no such handler
	DW 0 ; pointer to expansion device handler, 0 if no such handler
	DW 0 ; pointer to the start of a tokenized basicprogram, 0 if no basicprogram
	DW 0,0,0 ; room reserved for future extensions
initcode:

initgame:
	call init
	;call createbigcharset

startintroscreen:
	call initintronametable
	call ENASCR	; enable screen
	xor a
	ld (waitinterrupted),a
	ld hl,introscroltext
	call scrollbigtext
startintroscreen1:
	call bigscrollerwait
	jr z,startintroscreen1

startgame: 
	call initgamenametable
	call initscore
	call showscore
	call initplayfield
	call gridbitmap_to_grid10x10
	call selectnewplayablepieces
	call playablepieces_to_nametabel
	; shortcut since last elements is now already in mask
	ld a,2
	ld (pieceplayednowselected),a
	ld a,(pieceplayable3)
	ld (pieceplayednow),a
	call select_next_piece ; when we start the first piece is selected

	xor a
	ld (gameover),a
	call check_possible_gameover ; debug field might be to crowded...

maincount:
	call item_place_color
	call move_item_by_user
	ld a,(pieceplaceingrid)
	or a
	jr z,maincount3
	call drop_piece_in_grid
	jr z,maincount3 ; didn't drop anything
	call check_new_pieces_needed ; Z if new items
	call check_possible_gameover ; new or old items game over possible...
maincount3:
	ld a,(pieceplacenextpiece)
	or a
	call nz,select_next_piece
	ei
	halt
	call grid10x10_to_nametabel		; draw grid
	call item_to_nametabel		; draw item over grid
	call execroutine	; perform all extra routine before writting to vram the gridnametable, this allows extra animation in these routines to be displayed on top of the playingfield!
	call gridnametabel_to_vram
	call grid10x10_do_animation
	;no 10x10 disapear animation anymore and still no new itemselected...
	; auto select next piece
	ld a,(grid10x10_do_animation_inprogress)
	or a
	jr nz,maincount4
	ld a,(emptyitemmask)
	or a
	call z,select_next_piece
maincount4:
	halt
	call increasedisplayscore
	ld a,(gameover)
	or a
	jp z,maincount
	;show gameover
	call showgameover
	ld a,(waitinterrupted)
	or a
	jp z,startintroscreen
	jp startgame


init:
	; first clear all variables to zero
	;especially needed for the routeinstack!!
	ld de,#c001
	ld hl,#c000
	xor a
	ld (hl),a
	ld bc,endvarspace-#c000
	ldir
	ld a,2
	call CHGMOD	; screen 2
	xor a
	ld (CLIKSW),a	; disable keyboard click

	call DISSCR	; disable screen
	ld hl,vrampat1
	ld de,0
	ld bc,vrampat1end-vrampat1 ;256*8
	call LDIRVM	; copy patern table
	
commonchars equ 51
	ld hl,vrampat1
	ld de,256*8
	ld bc,commonchars*8
	call LDIRVM	; copy patern table
	ld hl,vrampat2
	ld de,256*8+commonchars*8
	ld bc,vrampat2end-vrampat2
	call LDIRVM	; copy patern table

	ld hl,vrampat1
	ld de,256*16
	ld bc,commonchars*8
	call LDIRVM	; copy patern table
	ld hl,vrampat3
	ld de,256*16+commonchars*8
	ld bc,vrampat3end-vrampat3
	call LDIRVM	; copy patern table

	ld hl,vramcol1
	ld de,0x2000
	ld bc,vramcol1end-vramcol1 ;256*8
	call LDIRVM	; copy color table

	ld hl,vramcol1
	ld de,0x2000+256*8
	ld bc,commonchars*8
	call LDIRVM	; copy color table
	ld hl,vramcol2
	ld de,0x2000+256*8+commonchars*8
	ld bc,vramcol2end-vramcol2 
	call LDIRVM	; copy color table

	ld hl,vramcol1
	ld de,0x2000+256*16
	ld bc,commonchars*8
	call LDIRVM	; copy color table
	ld hl,vramcol3
	ld de,0x2000+256*16+commonchars*8
	ld bc,vramcol3end-vramcol3 
	call LDIRVM	; copy color table

	ld hl,vramname1
	ld de,0x1800
	ld bc,vramname1end-vramname1
	call LDIRVM	; copy color table

	ret

initgamenametable:
	;copy nametabel to workarrea
	ld hl,vramname1
	ld de,nametabel
	ld bc,vramname1end-vramname1
	ldir

	; intro screen hiscore letters changed some chars so restore!
	ld hl,vrampat3
	ld de,256*16+commonchars*8
	ld bc,vrampat3end-vrampat3
	call LDIRVM	; copy patern table
	ld hl,vramcol3
	ld de,0x2000+256*16+commonchars*8
	ld bc,vramcol3end-vramcol3
	call LDIRVM	; copy color table

	ld hl,vramname1
	ld de,0x1800
	ld bc,vramname1end-vramname1
	call LDIRVM	; copy color table

	ret

initscore:
	ld hl,0
	ld (pieceoffset),hl
	xor a
	ld (pieceplaceingrid),a
	ld (pieceplacenextpiece),a

	ld hl,itemmask
	ld de,itemmask+1
	xor a
	ld (hl),a
	ld bc,20
	ldir

	xor a
	ld hl,realscore
	ld (hl),a
	ld de,realscore+1
	ld bc,23
	ldir
	ld a,3
	ld (increasedisplayspeedcnt),a
	ld (increasedisplayspeed),a
	ld a,255
	ld (hiscore),a
	ld (realscore),a
	ld (blockscore),a
	ld (displayscore),a
	ld (hiscore+7),a
	ld (realscore+7),a
	ld (blockscore+7),a
	ld (displayscore+7),a
	ld hl,#0
	ld (realscore+1),hl
	ld (realscore+3),hl
	ld hl,#0000
	ld (realscore+5),hl
	ret

initintronametabledb:
	db #48,#36,#4B,#46
	db #43,#3D,#39,#39
	db #4D,#36,#50,#47
	db #3D,#3D,#57,#57
	db #4C,#4C,#4C,#4C
	db #4C,#3E,#3E,#49
	INCLUDE "logo.asc"
initintronametable:
	; make the intro screen nametabel, uses char from game itself!
	; {{{ 
	ld hl,nametabel
	ld de,nametabel+1
	ld ix,initintronametabledb
	ld b,24
initintronametable1:
	push bc
	ld a,(ix+0)
	inc ix
	ld (hl),a
	ld bc,32
	ldir
	pop bc
	djnz initintronametable1
	; now copy logo to correct place
	ld hl,nametabel+8
	ld b,8
initintronametable2:
	push bc
	ld b,17
initintronametable3:
	ld a,(ix+0)
	inc ix
	or a
	jr z,initintronametable4
	ld (hl),a
initintronametable4:
	inc hl
	djnz initintronametable3
	ld de,32-17
	add hl,de
	pop bc
	djnz initintronametable2
	ld hl,initintronameplace
initintronametable5:
	ld e,(hl)
	inc hl
	ld d,(hl)
	ld a,e
	or d
	jr z,initintronametable6
	call initintronameblock
	jr initintronametable5
initintronametable6:
	; first make the scroll big charsset
	; it will place this in the 3 patgentabels so do this first we overwrite later
	call createbigcharset
	ld a,#fc
	ld hl,0x2000+256*8+128*8
	ld bc,128*8
	call FILVRM
	ld a,#f2
	ld hl,0x2000+512*8+128*8
	ld bc,128*8
	call FILVRM
	; add the new 125 and up chars
	ld hl,vrampatgameover
	ld de,141*8
	ld bc,vrampatgameoverend-vrampatgameover
	call LDIRVM	; copy patern table
	ld hl,vrampatgameover
	ld de,125*8
	ld bc,vrampatgameoverend-vrampatgameover
	call LDIRVM	; copy patern table
	ld a,#94
	ld hl,0x2000+125*8
	ld bc,vramcolgameoverend-vramcolgameover
	call FILVRM
	ld a,#95
	ld hl,0x2000+#90*8
	ld bc,vramcolgameoverend-vramcolgameover
	call FILVRM
	; add new characters for the 'start game' and hiscore text
scr1charstart:	equ 88
	ld hl,screen1chardb
	ld de,scr1charstart*8+256*8
	ld bc,128*8-scr1charstart*8
	;ld bc,screen1chardbend-screen1chardb
	;ld bc,75*8
	call LDIRVM
	ld hl,screen1chardb
	ld de,scr1charstart*8+512*8
	ld bc,128*8-scr1charstart*8
	;ld bc,screen1chardbend-screen1chardb
	;ld bc,75*8
	call LDIRVM
	ld a,#F7
	ld hl,0x2000+256*8+scr1charstart*8
	ld bc,128*8-scr1charstart*8
	;ld bc,screen1chardbend-screen1chardb
	call FILVRM
	ld a,#F3
	ld hl,0x2000+512*8+scr1charstart*8
	ld bc,128*8-scr1charstart*8
	;ld bc,screen1chardbend-screen1chardb
	call FILVRM

	ld hl,startgamedb
	ld de,nametabel+32*10+11
	ld bc,10
	ldir
	ld hl,startgamedb2
	ld de,nametabel+32*12+11
	ld bc,10
	ldir

	; show current hi-score
	ld hl,hiscore+1
	ld de,#1800+32*23+11 ; vram destination
	ld ix,nametabel+32*23+11
	ld bc,256*scr1charstart+#49 ; offset for numbers in b, empty char in c
	call shownumbers

	; prepare scroller
	ld de,30
	ld (scrollbuflength),de
	ld de,nametabel+14*32
	ld (scrollbufpnt),de
	ld de,scr1charstart
	ld (bigscrolcharspnt),de
	ld de,introbigcharconvert
	ld (bigchartosimpelcnvpnt),de
	ld de,bigscrolchr2vram2tabels
	ld (bigscrolchr2vrampnt),de
	xor a
	ld (scrollpage),a
	ld hl,scrollpatternendbuf
	ld de,scrollpatternendbuf+1
	ld bc,15
	ld (hl),a
	ldir
	dec a
	ld (scrollpatterncombinedb),a
	xor a
	ld (scrolltextcount),a
	ld a,2
	ld (scrolltextmaxcount),a

	; now show intro screen on screen
	ld hl,nametabel
	ld de,#1800
	ld bc,32*24
	jp LDIRVM ; jp instead of calll+ret
introbigcharconvert:
	; 0 is empty, 1 is completely full
	db  0, 0, 0, 0
	db  0, 2, 3, 0
	db  0, 5, 6, 0
	db  0, 0, 0, 0
	db  1, 1, 1, 1
	db  1,15,16, 1
	db  1,18,19, 1
	db  1, 1, 1, 1

startgamedb:
	db "D"-#30+scr1charstart-7
	db "I"-#30+scr1charstart-7
	db "F"-#30+scr1charstart-7
	db "F"-#30+scr1charstart-7
	db "I"-#30+scr1charstart-7
	db "C"-#30+scr1charstart-7
	db "U"-#30+scr1charstart-7
	db "L"-#30+scr1charstart-7
	db "T"-#30+scr1charstart-7
	db "Y"-#30+scr1charstart-7

startgamedb2:
	db "S"-#30+scr1charstart-7
	db "T"-#30+scr1charstart-7
	db "A"-#30+scr1charstart-7
	db "R"-#30+scr1charstart-7
	db "T"-#30+scr1charstart-7
	db " "-#30+scr1charstart-7
	db "G"-#30+scr1charstart-7
	db "A"-#30+scr1charstart-7
	db "M"-#30+scr1charstart-7
	db "E"-#30+scr1charstart-7

initintronameplace:
	dw nametabel+32*13+29
	dw nametabel+32*13+31
	dw nametabel+32*15+30
	dw nametabel+32*17+31
	dw nametabel+32*17+29
	dw nametabel+32*17+27
	dw nametabel+32*19+30
	dw nametabel+32*19+26
	dw nametabel+32*19+24
	dw nametabel+32*20+0
	dw nametabel+32*20+2
	dw nametabel+32*20+19
	dw nametabel+32*20+23
	dw nametabel+32*20+25
	dw nametabel+32*22+1
	dw nametabel+32*22+3
	dw nametabel+32*22+29
	dw 0
initintronameblock:
	push de
	pop ix
	ld a,12
	ld (ix+0),a
	inc a
	ld (ix+1),a
	inc a
	ld (ix+32),a
	inc a
	ld (ix+33),a
	ret
	; }}}

increasedisplayscore:
	; not every interrupt we want to check this!
	ld a,(increasedisplayspeedcnt)
	dec a
	ld (increasedisplayspeedcnt),a
	ret nz
	ld a,(increasedisplayspeed)
	ld (increasedisplayspeedcnt),a

	; time to check!
	; are we displaying correct  score?
	ld hl,displayscore+1
	ld de,realscore+1
	call bcdcmpdehl
	ret z

	; increase displayed score by one
	ld hl,displayscore+5+1
	ld de,score0001+5+1
	call bcdadddehl
showscore:
	ld hl,displayscore+1
	ld de,#1800+32*21+14-6 ; vram destination
	ld ix,nametabel+32*21+14-6
	ld bc,#3433 ; offset for numbers in b, empty char in c
	call shownumbers

	ld hl,displayscore+1
	ld de,#1800+32*22+14-6 ; vram destination
	ld ix,nametabel+32*22+14-6
	ld bc,#3f3e ; offset for numbers in b, empty char in c
	call shownumbers
	ret

	
shownumbers:
	push ix
	push bc
	push hl
	ex de,hl
	call SETWRT
	pop hl
	pop bc
	pop de
	ld a,b
	push af
	ld b,5 ; max number of invisible prefixes
shownumber1:
	ld a,(hl)
	or a
	jp nz,shownumbers3
	ld a,c
	out (#98),a
	ld (de),a
	inc de
	inc hl
	djnz shownumber1
shownumbers3:	
	inc b
	pop af
	ld c,a
shownumbers4:	
	ld a,(hl)
	add a,c
	out (#98),a
	inc hl
	ld (de),a
	inc de
	djnz shownumbers4
	ret
	
	
DESTPAGE:	db 0

vrampat1:	
	INCLUDE "vram-pat1.txt"
vrampat1end:
vrampat2:	
	INCLUDE "vram-pat2.txt"
vrampat2end:
vrampat3:	
	INCLUDE "vram-pat3.txt"
vrampat3end:


vramcol1:
	INCLUDE "vram-col1.txt"
vramcol1end:
vramcol2:
	INCLUDE "vram-col2.txt"
vramcol2end:
vramcol3:
	INCLUDE "vram-col3.txt"
vramcol3end:

vramname1:
	INCLUDE "vram-name.txt"
vramname1end:

vrampatgameover:
	INCLUDE "vram-patgameover.txt"
vrampatgameoverend:
vramcolgameover:
	INCLUDE "vram-colgameover.txt"
vramcolgameoverend:
vramnamegameover:
	INCLUDE "vram-namegameover.txt"
vramnamegameoverend:
screen1chardb:
	INCLUDE "charscr1.asc"
screen1chardbend:
introscroltext:	db "WELCOME TO BLOCK PUZZLE    "
	db "PLAY USING THE CURSORS "
	db "THE SPACEBAR AND THE M KEY "
	db "         "
	db 0
	INCLUDE "pieces.asc"
	INCLUDE "piecelib.asc"
	INCLUDE "joystick.asc"
	INCLUDE "gameover.asc"

score0001:	db 255,0,0,0,0,0,1,255

	INCLUDE "bcdlib.asc"
	INCLUDE "gridbitmapmanipulators.asc"
	INCLUDE "boxcopy.asc"
	INCLUDE "routines.asc"
	INCLUDE "charanimation.asc"
	INCLUDE "bigscroller.asc"

einde	equ $
	ds #8000-einde

	INCLUDE "variablespace.asc"


;	vim:foldmethod=marker:ft=z8a:ts=16
